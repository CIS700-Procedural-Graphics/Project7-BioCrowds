# BioCrowds
Biocrowds is a crowd simulation algorithm based on the formation of veination patterns on leaves. It prevents agents from colliding with each other on their way to their goal points using a notion of "personal space". Personal space is modelled with a space colonization algorithm. Markers (just points) are scattered throughout the simulation space, on the ground. At each simulation frame, each marker becomes "owned" by the agent closest to it (with some max distance representing an agent's perception). Agent velocity at the next frame is then computed using a sum of the displacement vectors to each of its markers. Because a marker can only be owned by one agent at a time, this technique prevents agents from colliding.

# The Framework Writup

My BioCrowds implementation basically contains a bunch of markers that are distributed across the plane. Here the plane is divided into a grid of a total of 25 cells where each cell holds 100 markers each. The Agents are positioned at the ends in both the scene and they randomply pic one of the poles as their goal in which case the goal changes its color to the color of the Agent. The Agents cross over from one side of the plane to the other side trying to reach their goal by acquiring markers along the way that are used to calculate the velocity of the Agents in the direction of the goal. The velocities of each Agent is updated per frame. The markers are assigned to each agent based on the closes Agent getting the marker and the process is optimised by only considering the cells that are around the marker position are considered and their markers are checked gainst the Agents. 

## Extra credit
There is a probalistic chance that an obstacle will show up on the plane in which case the Agents will have to avoid the obstacle and reach the other end. But, this implementation has a minor limitation that in certain cases when the markers are sparce or unavailable or the Agent is in the center of the obstacle then the agent only gets markers that are behind it in which case it does not have any marker contributing in its velocity towards the goal and it stops moving. I have tried fiddeling with the weighting construct I am using or adding some velocity along the goal regardlesss of the markers owned and a few other ways but they all turned out to be inconsistent and unreliable in handeling all the endge cases correctly.
I have left the functionality in the implementation and it will create an obstacle but it might be that the some Agents may get stuck.
